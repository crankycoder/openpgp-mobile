#include "test_framework.h"
#include "openpgp.h"
#include <string.h>

/*
 * Key Generation Integration Tests
 * 
 * These tests validate that keys generated by our C API can be successfully 
 * used for all cryptographic operations, ensuring full end-to-end functionality.
 */

/* Helper function to validate PGP key format */
static bool validate_pgp_key(const char* key, const char* expected_type) {
    if (!key || strlen(key) < 100) {
        return false;
    }
    
    char expected_begin[256];
    snprintf(expected_begin, sizeof(expected_begin), "-----BEGIN PGP %s KEY BLOCK-----", expected_type);
    
    if (!strstr(key, expected_begin)) {
        return false;
    }
    
    char expected_end[256];
    snprintf(expected_end, sizeof(expected_end), "-----END PGP %s KEY BLOCK-----", expected_type);
    
    if (!strstr(key, expected_end)) {
        return false;
    }
    
    return true;
}

/* Helper function to test encryption/decryption roundtrip */
static bool test_roundtrip_encryption(const char* public_key, const char* private_key, 
                                    const char* passphrase, const char* test_message) {
    // Encrypt with public key
    const char* recipients[] = { public_key };
    openpgp_result_t encrypt_result = openpgp_encrypt(test_message, recipients, 1, NULL);
    
    if (encrypt_result.error != OPENPGP_SUCCESS) {
        printf("      Encryption failed: %s\n", 
               encrypt_result.error_message ? encrypt_result.error_message : "Unknown error");
        openpgp_result_free(&encrypt_result);
        return false;
    }
    
    char* encrypted_message = (char*)encrypt_result.data;
    if (!encrypted_message) {
        printf("      No encrypted data returned\n");
        openpgp_result_free(&encrypt_result);
        return false;
    }
    
    // Decrypt with private key
    openpgp_result_t decrypt_result = openpgp_decrypt(encrypted_message, private_key, passphrase, NULL);
    
    bool success = false;
    if (decrypt_result.error == OPENPGP_SUCCESS && decrypt_result.data) {
        char* decrypted_message = (char*)decrypt_result.data;
        if (strcmp(test_message, decrypted_message) == 0) {
            success = true;
        } else {
            printf("      Message mismatch. Expected: '%s', Got: '%s'\n", 
                   test_message, decrypted_message);
        }
    } else {
        printf("      Decryption failed: %s\n", 
               decrypt_result.error_message ? decrypt_result.error_message : "Unknown error");
    }
    
    openpgp_result_free(&encrypt_result);
    openpgp_result_free(&decrypt_result);
    return success;
}

TEST_CASE(rsa_2048_generation_and_usage) {
    openpgp_result_t init_result = openpgp_init();
    
    if (init_result.error != OPENPGP_SUCCESS) {
        printf("      Skipping - bridge not available: %s\n", init_result.error_message);
        openpgp_result_free(&init_result);
        return 0;
    }
    openpgp_result_free(&init_result);
    
    TEST_START("Generate RSA 2048-bit keypair without passphrase");
    
    // Generate RSA 2048 key without passphrase
    openpgp_options_t options;
    openpgp_options_init_default(&options);
    options.name = "Integration Test User";
    options.email = "integration-test@example.com";
    options.passphrase = NULL; // No passphrase
    options.comment = "RSA 2048 Integration Test";
    options.key_options.algorithm = OPENPGP_ALGORITHM_RSA;
    options.key_options.rsa_bits = 2048;
    options.key_options.hash = OPENPGP_HASH_SHA256;
    
    openpgp_result_t gen_result = openpgp_generate_key_with_options(&options);
    
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, gen_result.error);
    TEST_ASSERT_NULL(gen_result.error_message);
    TEST_ASSERT_NOT_NULL(gen_result.data);
    
    openpgp_keypair_t* keypair = (openpgp_keypair_t*)gen_result.data;
    TEST_ASSERT_NOT_NULL(keypair->public_key);
    TEST_ASSERT_NOT_NULL(keypair->private_key);
    
    // Validate key format
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->public_key, "PUBLIC"));
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->private_key, "PRIVATE"));
    
    TEST_LOG("Generated RSA 2048 keypair successfully");
    
    // Test encryption/decryption roundtrip
    TEST_START("Test encryption/decryption roundtrip");
    
    const char* test_message = "Hello, RSA 2048 integration test!";
    TEST_ASSERT_TRUE(test_roundtrip_encryption(keypair->public_key, keypair->private_key, 
                                               NULL, test_message));
    
    TEST_LOG("RSA 2048 roundtrip encryption/decryption successful");
    
    // Test with different message sizes
    TEST_START("Test with larger message");
    
    const char* large_message = "This is a longer test message to verify that RSA 2048 "
                               "key generation produces keys that can handle various message "
                               "sizes correctly. The message should be encrypted and decrypted "
                               "without any issues, maintaining data integrity throughout the process.";
    
    TEST_ASSERT_TRUE(test_roundtrip_encryption(keypair->public_key, keypair->private_key, 
                                               NULL, large_message));
    
    TEST_LOG("RSA 2048 large message test successful");
    
    openpgp_result_free(&gen_result);
    openpgp_cleanup();
    return 0;
}

TEST_CASE(rsa_2048_with_passphrase_generation_and_usage) {
    openpgp_result_t init_result = openpgp_init();
    
    if (init_result.error != OPENPGP_SUCCESS) {
        printf("      Skipping - bridge not available: %s\n", init_result.error_message);
        openpgp_result_free(&init_result);
        return 0;
    }
    openpgp_result_free(&init_result);
    
    TEST_START("Generate RSA 2048-bit keypair with passphrase");
    
    const char* test_passphrase = "integration-test-passphrase-123";
    
    // Generate RSA 2048 key with passphrase
    openpgp_options_t options;
    openpgp_options_init_default(&options);
    options.name = "Integration Test User With Passphrase";
    options.email = "integration-test-passphrase@example.com";
    options.passphrase = test_passphrase;
    options.comment = "RSA 2048 Integration Test with Passphrase";
    options.key_options.algorithm = OPENPGP_ALGORITHM_RSA;
    options.key_options.rsa_bits = 2048;
    options.key_options.hash = OPENPGP_HASH_SHA256;
    
    openpgp_result_t gen_result = openpgp_generate_key_with_options(&options);
    
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, gen_result.error);
    TEST_ASSERT_NULL(gen_result.error_message);
    TEST_ASSERT_NOT_NULL(gen_result.data);
    
    openpgp_keypair_t* keypair = (openpgp_keypair_t*)gen_result.data;
    TEST_ASSERT_NOT_NULL(keypair->public_key);
    TEST_ASSERT_NOT_NULL(keypair->private_key);
    
    // Validate key format
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->public_key, "PUBLIC"));
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->private_key, "PRIVATE"));
    
    TEST_LOG("Generated RSA 2048 keypair with passphrase successfully");
    
    // Test encryption with public key, decryption with private key + correct passphrase
    TEST_START("Test encryption/decryption with correct passphrase");
    
    const char* test_message = "Hello, RSA 2048 with passphrase integration test!";
    TEST_ASSERT_TRUE(test_roundtrip_encryption(keypair->public_key, keypair->private_key, 
                                               test_passphrase, test_message));
    
    TEST_LOG("RSA 2048 with passphrase roundtrip successful");
    
    // Test decryption failure with wrong passphrase
    TEST_START("Test decryption failure with wrong passphrase");
    
    const char* recipients[] = { keypair->public_key };
    openpgp_result_t encrypt_result = openpgp_encrypt(test_message, recipients, 1, NULL);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, encrypt_result.error);
    
    char* encrypted_message = (char*)encrypt_result.data;
    
    // Try to decrypt with wrong passphrase
    openpgp_result_t decrypt_result = openpgp_decrypt(encrypted_message, keypair->private_key, 
                                                     "wrong-passphrase", NULL);
    
    // This should fail
    TEST_ASSERT_NOT_EQUAL(OPENPGP_SUCCESS, decrypt_result.error);
    TEST_LOG("Correctly failed decryption with wrong passphrase");
    
    // Try to decrypt with no passphrase
    openpgp_result_t decrypt_result2 = openpgp_decrypt(encrypted_message, keypair->private_key, 
                                                      NULL, NULL);
    
    // This should also fail
    TEST_ASSERT_NOT_EQUAL(OPENPGP_SUCCESS, decrypt_result2.error);
    TEST_LOG("Correctly failed decryption with no passphrase");
    
    openpgp_result_free(&encrypt_result);
    openpgp_result_free(&decrypt_result);
    openpgp_result_free(&decrypt_result2);
    openpgp_result_free(&gen_result);
    openpgp_cleanup();
    return 0;
}

TEST_CASE(ecdsa_p256_generation_and_usage) {
    openpgp_result_t init_result = openpgp_init();
    
    if (init_result.error != OPENPGP_SUCCESS) {
        printf("      Skipping - bridge not available: %s\n", init_result.error_message);
        openpgp_result_free(&init_result);
        return 0;
    }
    openpgp_result_free(&init_result);
    
    TEST_START("Generate ECDSA P-256 keypair without passphrase");
    
    // Generate ECDSA P-256 key without passphrase
    openpgp_options_t options;
    openpgp_options_init_default(&options);
    options.name = "ECDSA Integration Test User";
    options.email = "ecdsa-integration-test@example.com";
    options.passphrase = NULL; // No passphrase
    options.comment = "ECDSA P-256 Integration Test";
    options.key_options.algorithm = OPENPGP_ALGORITHM_ECDSA;
    options.key_options.curve = OPENPGP_CURVE_P256;
    options.key_options.hash = OPENPGP_HASH_SHA256;
    
    openpgp_result_t gen_result = openpgp_generate_key_with_options(&options);
    
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, gen_result.error);
    TEST_ASSERT_NULL(gen_result.error_message);
    TEST_ASSERT_NOT_NULL(gen_result.data);
    
    openpgp_keypair_t* keypair = (openpgp_keypair_t*)gen_result.data;
    TEST_ASSERT_NOT_NULL(keypair->public_key);
    TEST_ASSERT_NOT_NULL(keypair->private_key);
    
    // Validate key format
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->public_key, "PUBLIC"));
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->private_key, "PRIVATE"));
    
    TEST_LOG("Generated ECDSA P-256 keypair successfully");
    
    // Test encryption/decryption roundtrip
    TEST_START("Test ECDSA P-256 encryption/decryption roundtrip");
    
    const char* test_message = "Hello, ECDSA P-256 integration test!";
    TEST_ASSERT_TRUE(test_roundtrip_encryption(keypair->public_key, keypair->private_key, 
                                               NULL, test_message));
    
    TEST_LOG("ECDSA P-256 roundtrip encryption/decryption successful");
    
    // Test with passphrase version
    TEST_START("Generate ECDSA P-256 keypair with passphrase");
    
    openpgp_options_t options_with_pass = options;
    options_with_pass.passphrase = "ecdsa-test-passphrase";
    options_with_pass.email = "ecdsa-integration-test-passphrase@example.com";
    
    openpgp_result_t gen_result_pass = openpgp_generate_key_with_options(&options_with_pass);
    
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, gen_result_pass.error);
    openpgp_keypair_t* keypair_pass = (openpgp_keypair_t*)gen_result_pass.data;
    
    TEST_ASSERT_TRUE(test_roundtrip_encryption(keypair_pass->public_key, keypair_pass->private_key, 
                                               "ecdsa-test-passphrase", test_message));
    
    TEST_LOG("ECDSA P-256 with passphrase roundtrip successful");
    
    openpgp_result_free(&gen_result);
    openpgp_result_free(&gen_result_pass);
    openpgp_cleanup();
    return 0;
}

TEST_CASE(ed25519_generation_and_usage) {
    openpgp_result_t init_result = openpgp_init();
    
    if (init_result.error != OPENPGP_SUCCESS) {
        printf("      Skipping - bridge not available: %s\n", init_result.error_message);
        openpgp_result_free(&init_result);
        return 0;
    }
    openpgp_result_free(&init_result);
    
    TEST_START("Generate Ed25519 keypair without passphrase");
    
    // Generate Ed25519 key without passphrase
    openpgp_options_t options;
    openpgp_options_init_default(&options);
    options.name = "Ed25519 Integration Test User";
    options.email = "ed25519-integration-test@example.com";
    options.passphrase = NULL; // No passphrase
    options.comment = "Ed25519 Integration Test";
    options.key_options.algorithm = OPENPGP_ALGORITHM_EDDSA;
    options.key_options.curve = OPENPGP_CURVE_CURVE25519;
    options.key_options.hash = OPENPGP_HASH_SHA256;
    
    openpgp_result_t gen_result = openpgp_generate_key_with_options(&options);
    
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, gen_result.error);
    TEST_ASSERT_NULL(gen_result.error_message);
    TEST_ASSERT_NOT_NULL(gen_result.data);
    
    openpgp_keypair_t* keypair = (openpgp_keypair_t*)gen_result.data;
    TEST_ASSERT_NOT_NULL(keypair->public_key);
    TEST_ASSERT_NOT_NULL(keypair->private_key);
    
    // Validate key format
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->public_key, "PUBLIC"));
    TEST_ASSERT_TRUE(validate_pgp_key(keypair->private_key, "PRIVATE"));
    
    TEST_LOG("Generated Ed25519 keypair successfully");
    
    // Test encryption/decryption roundtrip
    TEST_START("Test Ed25519 encryption/decryption roundtrip");
    
    const char* test_message = "Hello, Ed25519 integration test!";
    TEST_ASSERT_TRUE(test_roundtrip_encryption(keypair->public_key, keypair->private_key, 
                                               NULL, test_message));
    
    TEST_LOG("Ed25519 roundtrip encryption/decryption successful");
    
    // Test with passphrase version
    TEST_START("Generate Ed25519 keypair with passphrase");
    
    openpgp_options_t options_with_pass = options;
    options_with_pass.passphrase = "ed25519-test-passphrase";
    options_with_pass.email = "ed25519-integration-test-passphrase@example.com";
    
    openpgp_result_t gen_result_pass = openpgp_generate_key_with_options(&options_with_pass);
    
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, gen_result_pass.error);
    openpgp_keypair_t* keypair_pass = (openpgp_keypair_t*)gen_result_pass.data;
    
    TEST_ASSERT_TRUE(test_roundtrip_encryption(keypair_pass->public_key, keypair_pass->private_key, 
                                               "ed25519-test-passphrase", test_message));
    
    TEST_LOG("Ed25519 with passphrase roundtrip successful");
    
    openpgp_result_free(&gen_result);
    openpgp_result_free(&gen_result_pass);
    openpgp_cleanup();
    return 0;
}

TEST_CASE(multi_recipient_with_generated_keys) {
    openpgp_result_t init_result = openpgp_init();
    
    if (init_result.error != OPENPGP_SUCCESS) {
        printf("      Skipping - bridge not available: %s\n", init_result.error_message);
        openpgp_result_free(&init_result);
        return 0;
    }
    openpgp_result_free(&init_result);
    
    TEST_START("Generate multiple keypairs of different types");
    
    const char* test_message = "Hello, multi-recipient test with generated keys!";
    
    // Generate RSA keypair
    openpgp_options_t rsa_options;
    openpgp_options_init_default(&rsa_options);
    rsa_options.name = "RSA Multi Recipient Test";
    rsa_options.email = "rsa-multi@example.com";
    rsa_options.passphrase = NULL;
    rsa_options.key_options.algorithm = OPENPGP_ALGORITHM_RSA;
    rsa_options.key_options.rsa_bits = 2048;
    
    openpgp_result_t rsa_result = openpgp_generate_key_with_options(&rsa_options);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, rsa_result.error);
    openpgp_keypair_t* rsa_keypair = (openpgp_keypair_t*)rsa_result.data;
    
    // Generate ECDSA keypair
    openpgp_options_t ecdsa_options;
    openpgp_options_init_default(&ecdsa_options);
    ecdsa_options.name = "ECDSA Multi Recipient Test";
    ecdsa_options.email = "ecdsa-multi@example.com";
    ecdsa_options.passphrase = NULL;
    ecdsa_options.key_options.algorithm = OPENPGP_ALGORITHM_ECDSA;
    ecdsa_options.key_options.curve = OPENPGP_CURVE_P256;
    
    openpgp_result_t ecdsa_result = openpgp_generate_key_with_options(&ecdsa_options);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, ecdsa_result.error);
    openpgp_keypair_t* ecdsa_keypair = (openpgp_keypair_t*)ecdsa_result.data;
    
    // Generate Ed25519 keypair
    openpgp_options_t ed25519_options;
    openpgp_options_init_default(&ed25519_options);
    ed25519_options.name = "Ed25519 Multi Recipient Test";
    ed25519_options.email = "ed25519-multi@example.com";
    ed25519_options.passphrase = NULL;
    ed25519_options.key_options.algorithm = OPENPGP_ALGORITHM_EDDSA;
    ed25519_options.key_options.curve = OPENPGP_CURVE_CURVE25519;
    
    openpgp_result_t ed25519_result = openpgp_generate_key_with_options(&ed25519_options);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, ed25519_result.error);
    openpgp_keypair_t* ed25519_keypair = (openpgp_keypair_t*)ed25519_result.data;
    
    TEST_LOG("Generated RSA, ECDSA, and Ed25519 keypairs successfully");
    
    // Test multi-recipient encryption
    TEST_START("Test multi-recipient encryption to all key types");
    
    const char* recipients[] = {
        rsa_keypair->public_key,
        ecdsa_keypair->public_key,
        ed25519_keypair->public_key
    };
    
    openpgp_result_t encrypt_result = openpgp_encrypt(test_message, recipients, 3, NULL);
    if (encrypt_result.error != OPENPGP_SUCCESS) {
        printf("      Multi-recipient encryption failed: %s\n", 
               encrypt_result.error_message ? encrypt_result.error_message : "Unknown error");
        printf("      This may be expected if Ed25519 doesn't support encryption\n");
        
        // Try with just RSA and ECDSA
        const char* rsa_ecdsa_recipients[] = {
            rsa_keypair->public_key,
            ecdsa_keypair->public_key
        };
        
        openpgp_result_t rsa_ecdsa_result = openpgp_encrypt(test_message, rsa_ecdsa_recipients, 2, NULL);
        if (rsa_ecdsa_result.error == OPENPGP_SUCCESS) {
            printf("      RSA + ECDSA encryption works, Ed25519 may not support encryption\n");
            encrypt_result = rsa_ecdsa_result;
        } else {
            printf("      RSA + ECDSA also failed: %s\n", 
                   rsa_ecdsa_result.error_message ? rsa_ecdsa_result.error_message : "Unknown error");
            openpgp_result_free(&rsa_ecdsa_result);
        }
    }
    
    if (encrypt_result.error != OPENPGP_SUCCESS) {
        // Skip the rest of the test if encryption failed
        openpgp_result_free(&encrypt_result);
        openpgp_result_free(&rsa_result);
        openpgp_result_free(&ecdsa_result);
        openpgp_result_free(&ed25519_result);
        openpgp_cleanup();
        return 0;
    }
    
    TEST_ASSERT_NOT_NULL(encrypt_result.data);
    
    char* encrypted_message = (char*)encrypt_result.data;
    TEST_LOG("Multi-recipient encryption successful");
    
    // Test that each recipient can decrypt
    TEST_START("Test RSA recipient can decrypt");
    openpgp_result_t rsa_decrypt = openpgp_decrypt(encrypted_message, rsa_keypair->private_key, NULL, NULL);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, rsa_decrypt.error);
    TEST_ASSERT_STRING_EQUAL(test_message, (char*)rsa_decrypt.data);
    TEST_LOG("RSA recipient decryption successful");
    
    TEST_START("Test ECDSA recipient can decrypt");
    openpgp_result_t ecdsa_decrypt = openpgp_decrypt(encrypted_message, ecdsa_keypair->private_key, NULL, NULL);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, ecdsa_decrypt.error);
    TEST_ASSERT_STRING_EQUAL(test_message, (char*)ecdsa_decrypt.data);
    TEST_LOG("ECDSA recipient decryption successful");
    
    TEST_START("Test Ed25519 recipient can decrypt");
    openpgp_result_t ed25519_decrypt = openpgp_decrypt(encrypted_message, ed25519_keypair->private_key, NULL, NULL);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, ed25519_decrypt.error);
    TEST_ASSERT_STRING_EQUAL(test_message, (char*)ed25519_decrypt.data);
    TEST_LOG("Ed25519 recipient decryption successful");
    
    // Cleanup
    openpgp_result_free(&rsa_result);
    openpgp_result_free(&ecdsa_result);
    openpgp_result_free(&ed25519_result);
    openpgp_result_free(&encrypt_result);
    openpgp_result_free(&rsa_decrypt);
    openpgp_result_free(&ecdsa_decrypt);
    openpgp_result_free(&ed25519_decrypt);
    
    openpgp_cleanup();
    return 0;
}

TEST_CASE(key_metadata_extraction_on_generated_keys) {
    openpgp_result_t init_result = openpgp_init();
    
    if (init_result.error != OPENPGP_SUCCESS) {
        printf("      Skipping - bridge not available: %s\n", init_result.error_message);
        openpgp_result_free(&init_result);
        return 0;
    }
    openpgp_result_free(&init_result);
    
    TEST_START("Generate test keypairs for metadata extraction");
    
    // Generate RSA keypair
    openpgp_options_t rsa_options;
    openpgp_options_init_default(&rsa_options);
    rsa_options.name = "RSA Metadata Test User";
    rsa_options.email = "rsa-metadata@example.com";
    rsa_options.passphrase = "metadata-test-pass";
    rsa_options.comment = "RSA Metadata Test";
    rsa_options.key_options.algorithm = OPENPGP_ALGORITHM_RSA;
    rsa_options.key_options.rsa_bits = 2048;
    
    openpgp_result_t rsa_result = openpgp_generate_key_with_options(&rsa_options);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, rsa_result.error);
    openpgp_keypair_t* rsa_keypair = (openpgp_keypair_t*)rsa_result.data;
    
    // Test public key metadata extraction
    TEST_START("Extract RSA public key metadata");
    
    openpgp_result_t pub_meta_result = openpgp_get_public_key_metadata(rsa_keypair->public_key);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, pub_meta_result.error);
    TEST_ASSERT_NOT_NULL(pub_meta_result.data);
    
    openpgp_public_key_metadata_t* pub_meta = (openpgp_public_key_metadata_t*)pub_meta_result.data;
    TEST_ASSERT_NOT_NULL(pub_meta->algorithm);
    TEST_ASSERT_NOT_NULL(pub_meta->key_id);
    TEST_ASSERT_NOT_NULL(pub_meta->fingerprint);
    TEST_ASSERT_NOT_NULL(pub_meta->creation_time);
    
    // Verify algorithm detection
    printf("      Algorithm reported: %s\n", pub_meta->algorithm ? pub_meta->algorithm : "NULL");
    TEST_ASSERT_TRUE(strstr(pub_meta->algorithm, "RSA") != NULL || 
                     strstr(pub_meta->algorithm, "rsa") != NULL);
    TEST_LOG("RSA algorithm correctly detected in public key metadata");
    
    // Test private key metadata extraction
    TEST_START("Extract RSA private key metadata");
    
    openpgp_result_t priv_meta_result = openpgp_get_private_key_metadata(rsa_keypair->private_key);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, priv_meta_result.error);
    TEST_ASSERT_NOT_NULL(priv_meta_result.data);
    
    openpgp_private_key_metadata_t* priv_meta = (openpgp_private_key_metadata_t*)priv_meta_result.data;
    TEST_ASSERT_NOT_NULL(priv_meta->key_id);
    TEST_ASSERT_NOT_NULL(priv_meta->fingerprint);
    TEST_ASSERT_NOT_NULL(priv_meta->creation_time);
    
    // Verify that private key is encrypted (has passphrase)
    TEST_ASSERT_EQUAL(true, priv_meta->encrypted);
    TEST_LOG("Private key correctly detected as encrypted");
    
    // Verify key IDs match between public and private
    TEST_ASSERT_STRING_EQUAL(pub_meta->key_id, priv_meta->key_id);
    TEST_ASSERT_STRING_EQUAL(pub_meta->fingerprint, priv_meta->fingerprint);
    TEST_LOG("Key IDs and fingerprints match between public and private keys");
    
    // Test ECDSA key metadata
    TEST_START("Generate and test ECDSA key metadata");
    
    openpgp_options_t ecdsa_options;
    openpgp_options_init_default(&ecdsa_options);
    ecdsa_options.name = "ECDSA Metadata Test User";
    ecdsa_options.email = "ecdsa-metadata@example.com";
    ecdsa_options.passphrase = NULL; // No passphrase
    ecdsa_options.key_options.algorithm = OPENPGP_ALGORITHM_ECDSA;
    ecdsa_options.key_options.curve = OPENPGP_CURVE_P256;
    
    openpgp_result_t ecdsa_result = openpgp_generate_key_with_options(&ecdsa_options);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, ecdsa_result.error);
    openpgp_keypair_t* ecdsa_keypair = (openpgp_keypair_t*)ecdsa_result.data;
    
    openpgp_result_t ecdsa_pub_meta = openpgp_get_public_key_metadata(ecdsa_keypair->public_key);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, ecdsa_pub_meta.error);
    
    openpgp_public_key_metadata_t* ecdsa_meta = (openpgp_public_key_metadata_t*)ecdsa_pub_meta.data;
    printf("      ECDSA Algorithm reported: %s\n", ecdsa_meta->algorithm ? ecdsa_meta->algorithm : "NULL");
    TEST_ASSERT_TRUE(strstr(ecdsa_meta->algorithm, "ECDSA") != NULL || 
                     strstr(ecdsa_meta->algorithm, "ECC") != NULL ||
                     strstr(ecdsa_meta->algorithm, "ecdsa") != NULL ||
                     strstr(ecdsa_meta->algorithm, "ecc") != NULL);
    TEST_LOG("ECDSA algorithm correctly detected");
    
    openpgp_result_t ecdsa_priv_meta = openpgp_get_private_key_metadata(ecdsa_keypair->private_key);
    TEST_ASSERT_EQUAL(OPENPGP_SUCCESS, ecdsa_priv_meta.error);
    
    openpgp_private_key_metadata_t* ecdsa_priv = (openpgp_private_key_metadata_t*)ecdsa_priv_meta.data;
    TEST_ASSERT_EQUAL(false, ecdsa_priv->encrypted); // No passphrase
    TEST_LOG("ECDSA private key correctly detected as unencrypted");
    
    // Cleanup
    openpgp_result_free(&rsa_result);
    openpgp_result_free(&pub_meta_result);
    openpgp_result_free(&priv_meta_result);
    openpgp_result_free(&ecdsa_result);
    openpgp_result_free(&ecdsa_pub_meta);
    openpgp_result_free(&ecdsa_priv_meta);
    
    openpgp_cleanup();
    return 0;
}